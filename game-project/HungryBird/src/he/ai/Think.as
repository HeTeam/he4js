package he.ai
{
	/**
	 * Think 思维控制器 。
	 * 1、信号输入，将信号抽象转换成节点，多个节点进一步抽象成更少的节点直到抽象成一个节点，在界面（UI）中展示抽象出的节点树。
	 * 2、抽象过程中不断从记忆（Net）中提取相似的节点进行对比。
	 * 3、控制器查看抽象出的节点树，在树中查找需求。
	 * 4、根据需求进行联想，并从 Net 中提取。
	 * 5、将联想到的节点构建成一颗行为树，并在 UI 中呈现。
	 * 6、搜索行为树，找到可以输出的多个节点。（比如，距离，缩短距离，金钱，提款或工作）
	 * 7、评估多个分支的收益，从收益效率最高的节点开始尝试。（不一定是从收益最高的节点开始，有些事情不重要但很紧急，比如学习收益最高，但灭火更紧急）
	 * 8、根据外部世界的变化，重新运算当前树或分支节点的收益，并重新排序。
	 * 9、继续运转行为树（或多个层次的行为树），定时回到第 8 项。
	 * 10、直到达成，或因中途收益变化等原因，临时暂停或终止。
	 * 11、在没有强烈的外部刺激的情况下，根据需求，建立一颗宏观树，对外部世界进行互动和尝试，学习更多知识，以便于将来更高效的与世界互动。
	 * 
	 * 控制器细节描述（计划）：
	 * a、当场景中生成一个物体时，同时创建一个节点（Node），导入这个物体的颜色、大小、位置、各种抽象类别，成为这个节点的子节点（需要突触的帮助来指向子节点）。
	 * b、将创建的节点存入网络存储器（Net），并分配一个坐标（坐标分配法则需完善）。
	 * c、发送消息给外部。
	 * d、UI 接收到消息后，根据坐标，显示这个新创建的节点。
	 * e、当用户点击这个节点时，节点细节面板（NodeDetailPanel）负责显示它的突触列表，以及突触所指向的节点和数值，点击突触，对应的节点会闪烁，对应的场景实例也会闪烁。
	 * f、存在一个步进器（StepPanel）用于负责指定思维控制器的运转速度（每隔多少秒运转一次），同时负责打印富文本的文字输出（包含节点，实物按钮，可点击后指向对应的物体）。
	 * g、节点生成后，跟现有节点做对比，进行抽象，抽象查找方法待定，可能需要从最高级的物品节点搜索？或者 MD5？或者id字符排序拼凑？二叉树？。
	 * h、严谨抽象：突触数量相同，突触上的链接强度相同，指向的节点也相同，则认为完全一样。
	 * i、宽松抽象：突触数量不同，但关键的 N 个突触所指向的的节点都相同，并且链接强度在一定阈值范围内，则认为相同（此阈值由什么决定，识别效率？待完善）
	 * j、视觉抽象需要从点线面入手（暂不考虑）。
	 * k、节点可人为附加关联词汇，方便打印输出。
	 * l、节点可人为绑定函数或机械装置（一个轴向）。
	 * m、节点可抽象出正值和负值（不确定，待完善）。
	 * n、添加一个距离判断函数。
	 * o、找到距离抽象节点，绑定小鸟的预制飞行功能（等于暂时省略了小脑的功能，直接赋予小鸟飞行能力）。
	 * p、节点可绑定需求（一个轴向或一个节点？）。
	 * q、根据需求，查找子节点，（注意去重），找到 10 个左右的相关节点。
	 * r、查找后进行价值评估，并构建行为路径（小鸟暂不需要躲避什么，所以只需要构建单条路径）或行为树（买东西的路上需要躲避汽车，所以复杂情况需要分支）。
	 * s、根据步进器的时间限制来运转行为树，遇到意外情况，外部行为树可暂停当前树。
	 * t、当满足需求时，采取预制行动。
	 * u、当不满足需求时，重新根据需求构建行为树。（是否需要调整策略？或只根据观察统计更新突触的值？很可能，比如距离远吃不到等情况，参考 he4o 的论述）
	 * v、当满足需求时，将行为树抽象成一个行为节点，关联到需求节点。（待完善）
	 * w、等待，观察世界。
	 * x、清理不存在的节点。
	 * y、清理不重要的节点。
	 * z、睡眠时，节点 UI 坐标根据相关度，自动排列布局？节点 UI 是否需要 3d 化？
	 */
	public class Think
	{
		public function Think()
		{
			// todo
		}
		public function dataIn():void
		{
			// todo
		}
	}
}